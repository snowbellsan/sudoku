<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ•°ç‹¬ãƒ‘ã‚ºãƒ« å®Œå…¨ç‰ˆ</title>
<style>
/* ============================================================
 * 1. ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒ¢ãƒã‚¤ãƒ«ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªè¨­å®š
 * ============================================================ */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
    min-height: 100vh;
    padding: 5px;
    padding-bottom: 10px;
    overflow-x: hidden;
}

h2 {
    margin: 8px 0;
    color: #1565c0;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    font-size: 1.5em;
}

/* ============================================================
 * 2. çµ±è¨ˆæƒ…å ± (Stats) - æ™‚é–“è¡¨ç¤º
 * ============================================================ */
#stats {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 95vw;
    max-width: 450px;
    margin-bottom: 10px;
    font-size: 1.1em; 
    padding: 8px 0;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.15);
    color: #1565c0;
    font-weight: 600;
}

#stats div {
    padding: 0 20px;
}

/* ============================================================
 * 3. æ•°ç‹¬ã‚°ãƒªãƒƒãƒ‰ (Grid)
 * ============================================================ */
#grid {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    grid-template-rows: repeat(9, 1fr);
    width: 95vw;
    max-width: 450px;
    aspect-ratio: 1 / 1;
    border: 3px solid #1565c0;
    margin-bottom: 10px;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-radius: 4px;
}

.cell {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.0em;
    border: 1px solid #ccc;
    cursor: pointer;
    user-select: none;
    position: relative;
    transition: background-color 0.2s;
}

/* 3x3ãƒ–ãƒ­ãƒƒã‚¯ã®å¤ªç·š */
.cell[data-r="2"],
.cell[data-r="5"] { 
    border-bottom: 2px solid #1565c0; 
}

.cell[data-c="2"],
.cell[data-c="5"] { 
    border-right: 2px solid #1565c0; 
}

/* é¸æŠä¸­ã®ã‚»ãƒ« */
.cell.selected {
    background-color: #b3e5fc !important;
    border-color: #0288d1;
    box-shadow: 0 0 8px rgba(2, 136, 209, 0.6);
}

/* é–¢é€£ã‚»ãƒ« (è¡Œãƒ»åˆ—ãƒ»ãƒ–ãƒ­ãƒƒã‚¯) ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ */
.cell.highlighted {
    background-color: #e1f5fe;
}

/* ãƒ’ãƒ³ãƒˆï¼ˆå›ºå®šå€¤ï¼‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.cell.fixed {
    background-color: #f5f5f5;
    font-weight: bold;
    color: #424242;
}

/* ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›å€¤ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.cell:not(.fixed) {
    color: #1976d2;
    font-weight: 500;
}

/* ã‚¨ãƒ©ãƒ¼ï¼ˆé‡è¤‡ ã¾ãŸã¯ è§£ç­”ä¸æ­£è§£ï¼‰ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.cell.error {
    background-color: #ffcdd2 !important;
    color: #c62828 !important; /* èµ¤è‰²ã®æ–‡å­— */
    font-weight: 600;
}

/* ãƒ¡ãƒ¢æ•°å­—ã®ã‚³ãƒ³ãƒ†ãƒŠ */
.memo-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    width: 100%;
    height: 100%;
    font-size: 0.5em; 
    line-height: 1;
    color: #757575;
    opacity: 0.8;
}

.memo-container span {
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: normal;
}

/* ============================================================
 * 4. ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (é †åºå¤‰æ›´)
 * ============================================================ */
#keypad {
    display: grid;
    grid-template-columns: repeat(3, 1fr) 1fr 1fr;
    grid-template-rows: repeat(3, 1fr);
    gap: 6px;
    width: 95vw;
    max-width: 450px;
    padding: 10px;
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

#keypad button {
    width: 100%;
    height: 55px;
    font-size: 1.8em;
    padding: 0;
    background-color: #fff;
    color: #1565c0;
    border: 2px solid #90caf9;
    font-weight: 600;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#keypad button:hover:not(:disabled) {
    background-color: #e3f2fd;
    border-color: #42a5f5;
}

/* ä¿®æ­£ç®‡æ‰€: grid-row: 1 / 4; ã«å¤‰æ›´ã—ã¦ç¸¦ã«ä¼¸ã°ã™ */
#memo-toggle {
    font-size: 0.55em;
    background-color: #ff9800;
    color: white;
    border-color: #ff9800;
    font-weight: 600;
    line-height: 1.2;
    grid-column: 4;
    grid-row: 1 / 4;
}

#memo-toggle:hover:not(:disabled) {
    background-color: #f57c00;
    border-color: #f57c00;
}

.memo-mode-active {
    background-color: #4caf50 !important;
    color: white !important;
    border-color: #4caf50 !important;
}

.memo-mode-active:hover:not(:disabled) {
    background-color: #388e3c !important;
    border-color: #388e3c !important;
}

/* ä¿®æ­£ç®‡æ‰€: grid-row: 1 / 4; ã«å¤‰æ›´ã—ã¦ç¸¦ã«ä¼¸ã°ã™ */
.keypad-clear {
    font-size: 0.7em;
    background-color: #f44336 !important;
    color: white !important;
    border-color: #f44336 !important;
    font-weight: 600;
    grid-column: 5;
    grid-row: 1 / 4;
}

.keypad-clear:hover:not(:disabled) {
    background-color: #d32f2f !important;
    border-color: #d32f2f !important;
}

#controls {
    margin: 0 0 10px;
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: center;
    width: 95vw;
    max-width: 450px;
}

#controls label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 500;
    color: #424242;
}

#controls select {
    padding: 6px 10px;
    font-size: 14px;
    border: 2px solid #90caf9;
    border-radius: 5px;
    background-color: #fff;
    color: #1565c0;
    font-weight: 500;
    cursor: pointer;
    transition: border-color 0.2s;
}

#controls select:hover {
    border-color: #42a5f5;
}

button {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    border: 2px solid #1976d2;
    background: #1976d2;
    color: white;
    border-radius: 5px;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    font-weight: 500;
}

button:hover:not(:disabled) {
    background: #1565c0;
    border-color: #1565c0;
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
}

button:active:not(:disabled) {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

#controls button {
    background: #757575;
    border-color: #757575;
}

#controls button:hover:not(:disabled) {
    background: #616161;
    border-color: #616161;
}

/* ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ONæ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
#check-toggle.check-mode-active {
    background: #00bcd4 !important; /* ã‚·ã‚¢ãƒ³ç³» */
    border-color: #00bcd4 !important;
}
#check-toggle.check-mode-active:hover {
    background: #0097a7 !important;
    border-color: #0097a7 !important;
}

/* ============================================================
 * 6. ã‚«ã‚¹ã‚¿ãƒ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®ã‚¹ã‚¿ã‚¤ãƒ«
 * ============================================================ */
#custom-dialog {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none; 
    z-index: 1000; 
    justify-content: center;
    align-items: flex-end; /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¸‹ç«¯ã«å¯„ã›ã‚‹ */
    padding: 10px;
}

#custom-dialog.show {
    display: flex; 
}

.dialog-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    width: 95vw;
    max-width: 450px;
    text-align: center;
    margin-bottom: 20px; 
    animation: slideUp 0.3s ease-out forwards; 
}

@keyframes slideUp {
    from {
        transform: translateY(100%);
        opacity: 0.5;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

#dialog-title {
    color: #f44336;
    margin-bottom: 10px;
}

#dialog-message {
    margin-bottom: 20px;
    color: #424242;
    white-space: pre-wrap;
}

.dialog-buttons button {
    margin: 0 5px;
    padding: 10px 20px;
    font-size: 16px;
    font-weight: 600;
}

.btn-confirm {
    background: #4caf50;
    border-color: #4caf50;
}

.btn-confirm:hover {
    background: #388e3c;
    border-color: #388e3c;
}

.btn-cancel {
    background: #757575;
    border-color: #757575;
}

.btn-cancel:hover {
    background: #616161;
    border-color: #616161;
}

/* ============================================================
 * 7. ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
 * ============================================================ */
@media (min-width: 600px) {
    body {
        padding: 20px;
    }
    
    h2 {
        font-size: 2em;
        margin: 15px 0;
    }
    
    #stats {
        font-size: 1.2em;
        padding: 12px 0;
        margin-bottom: 15px;
    }
    
    #grid {
        margin-bottom: 20px;
    }
    
    #controls {
        gap: 10px;
        margin-bottom: 15px;
    }
    
    #controls select {
        padding: 8px 12px;
        font-size: 16px;
    }
    
    button {
        padding: 10px 16px;
        font-size: 16px;
    }
    
    #keypad {
        gap: 8px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    #keypad button {
        height: 60px;
        font-size: 1.5em;
    }
    
    #grid, #stats, #controls, #keypad {
        width: 450px;
    }
}

@media (max-width: 400px) {
    h2 {
        font-size: 1.3em;
        margin: 5px 0;
    }
    
    #stats {
        font-size: 1em;
        padding: 6px 0;
    }
    
    .cell {
        font-size: 1.6em;
    }
    
    #keypad button {
        height: 48px;
        font-size: 1.6em;
    }
    
    #memo-toggle,
    .keypad-clear {
        font-size: 0.4em;
    }
    
    #controls select {
        font-size: 12px;
        padding: 5px 8px;
    }
    
    button {
        font-size: 12px;
        padding: 6px 10px;
    }
}

@media (max-width: 360px) {
    h2 {
        font-size: 1.2em;
    }
    
    #stats {
        font-size: 0.9em;
    }
    
    .cell {
        font-size: 1.4em;
    }
    
    #keypad button {
        height: 45px;
        font-size: 1.5em;
    }
    
    #keypad {
        gap: 4px;
        padding: 8px;
    }
}
</style>
</head>
<body>

<div id="custom-dialog">
    <div class="dialog-content">
        <h3 id="dialog-title">ç¢ºèª</h3>
        <p id="dialog-message">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</p>
        <div class="dialog-buttons">
            <button class="btn-confirm" id="dialog-confirm">OK</button>
            <button class="btn-cancel" id="dialog-cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>
</div>

<h2>ğŸ¯ æ•°ç‹¬ãƒ‘ã‚ºãƒ«</h2>

<div id="stats">
    <div>â³ æ™‚é–“: <span id="time">00:00</span></div>
</div>

<div id="grid"></div>

<div id="keypad">
    <button onclick="handleKeypadInput(1)">1</button>
    <button onclick="handleKeypadInput(2)">2</button>
    <button onclick="handleKeypadInput(3)">3</button>
    <button id="memo-toggle" onclick="toggleMemoMode()">ãƒ¡ãƒ¢<br>(OFF)</button>
    <button class="keypad-clear" onclick="handleKeypadInput(0)">æ¶ˆå»</button>
    
    <button onclick="handleKeypadInput(4)">4</button>
    <button onclick="handleKeypadInput(5)">5</button>
    <button onclick="handleKeypadInput(6)">6</button>
    
    <button onclick="handleKeypadInput(7)">7</button>
    <button onclick="handleKeypadInput(8)">8</button>
    <button onclick="handleKeypadInput(9)">9</button>
</div>

<div id="controls">
    <label>æ‰‹ãŒã‹ã‚Šæ•°:
        <select id="clues">
            <option value="36">36ï¼ˆã‚„ã•ã—ã„ï¼‰</option>
            <option value="30">30ï¼ˆãµã¤ã†ï¼‰</option>
            <option value="22" selected>22ï¼ˆã‚€ãšã‹ã—ã„ï¼‰</option>
            <option value="17">17ï¼ˆè¶…é›£é–¢ï¼‰</option>
        </select>
    </label>
    <button id="check-toggle" onclick="toggleCheckMode()">ğŸ” ãƒ’ãƒ³ãƒˆ (ON)</button>
    <button onclick="generatePuzzle()">ğŸ”„ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    <button onclick="confirmGiveUp()">ğŸ³ï¸ ã‚®ãƒ–ã‚¢ãƒƒãƒ—</button> 
    <button onclick="resetPuzzle()">â†©ï¸ ãƒªã‚»ãƒƒãƒˆ</button>
    <button onclick="undo()">â¬…ï¸ å…ƒã«æˆ»ã™</button>
</div>

<script>
// ============================================================
// å®šæ•°ã¨çŠ¶æ…‹ç®¡ç†
// ============================================================
const SIZE = 9;
const CELL_COUNT = 81;
const gridElement = document.getElementById("grid");
const timeElement = document.getElementById("time");
const memoToggleButton = document.getElementById("memo-toggle");

let solutionGrid = [];
let initialPuzzle = [];
let selectedCell = null;

let timerInterval = null;
let seconds = 0;
let isMemoMode = false;
let isCheckMode = true; // â˜…è¿½åŠ : ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ã®çŠ¶æ…‹ï¼ˆåˆæœŸå€¤ã¯ONï¼‰

// Undoæ©Ÿèƒ½ã®ãŸã‚ã®å±¥æ­´ã‚¹ã‚¿ãƒƒã‚¯
let history = []; 
const MAX_HISTORY = 50;

// ã‚«ã‚¹ã‚¿ãƒ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®è¦ç´ 
let customDialog = document.getElementById('custom-dialog');
let dialogTitle = document.getElementById('dialog-title');
let dialogMessage = document.getElementById('dialog-message');
let dialogConfirmBtn = document.getElementById('dialog-confirm');
let dialogCancelBtn = document.getElementById('dialog-cancel');

// ============================================================
// ã‚«ã‚¹ã‚¿ãƒ ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
// ============================================================

function showConfirmDialog(title, message) {
    return new Promise((resolve) => {
        // è¦ç´ ã‚’å†å–å¾—ï¼ˆDOMãŒæ›´æ–°ã•ã‚ŒãŸå ´åˆã«å‚™ãˆã¦ï¼‰
        customDialog = document.getElementById('custom-dialog');
        dialogTitle = document.getElementById('dialog-title');
        dialogMessage = document.getElementById('dialog-message');
        const confirmBtn = document.getElementById('dialog-confirm');
        const cancelBtn = document.getElementById('dialog-cancel');
        
        dialogTitle.textContent = title;
        dialogMessage.textContent = message;
        customDialog.classList.add('show');
        
        // å…±é€šã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°
        const cleanup = (result) => {
            customDialog.classList.remove('show');
            confirmBtn.removeEventListener('click', handleConfirm);
            cancelBtn.removeEventListener('click', handleCancel);
            customDialog.removeEventListener('click', handleBackgroundClick);
            resolve(result);
        };
        
        const handleConfirm = () => {
            cleanup(true);
        };
        
        const handleCancel = () => {
            cleanup(false);
        };
        
        // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        const handleBackgroundClick = (e) => {
            if (e.target === customDialog) {
                cleanup(false);
            }
        };
        
        confirmBtn.addEventListener('click', handleConfirm);
        cancelBtn.addEventListener('click', handleCancel);
        customDialog.addEventListener('click', handleBackgroundClick);
    });
} 

// ============================================================
// æ•°ç‹¬ã‚³ã‚¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
// ============================================================

function createEmptyGrid() {
    return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
}

function getGridValuesFromCells() {
    let grid = createEmptyGrid();
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
            grid[r][c] = parseInt(cell.dataset.value || "0");
        }
    }
    return grid;
}

function isValid(grid, r, c, val) {
    if (val === 0) return true;
    
    // è¡Œã®ãƒã‚§ãƒƒã‚¯
    for (let x = 0; x < SIZE; x++) {
        if (x !== c && grid[r][x] === val) return false;
    }
    
    // åˆ—ã®ãƒã‚§ãƒƒã‚¯
    for (let y = 0; y < SIZE; y++) {
        if (y !== r && grid[y][c] === val) return false;
    }
    
    // 3x3ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚§ãƒƒã‚¯
    const br = Math.floor(r / 3) * 3;
    const bc = Math.floor(c / 3) * 3;
    for (let y = br; y < br + 3; y++) {
        for (let x = bc; x < bc + 3; x++) {
            if ((y !== r || x !== c) && grid[y][x] === val) return false;
        }
    }
    
    return true;
}

function findEmpty(grid) {
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] === 0) return [r, c];
        }
    }
    return null;
}

function fillGrid(grid) {
    const pos = findEmpty(grid);
    if (!pos) return true;
    
    const [r, c] = pos;
    const nums = [...Array(SIZE).keys()].map(n => n + 1);
    shuffle(nums);
    
    for (const n of nums) {
        if (isValid(grid, r, c, n)) {
            grid[r][c] = n;
            if (fillGrid(grid)) return true;
            grid[r][c] = 0;
        }
    }
    return false;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

function countSolutions(grid) {
    const pos = findEmpty(grid);
    if (!pos) return 1;
    
    const [r, c] = pos;
    let count = 0;
    
    for (let n = 1; n <= SIZE; n++) {
        if (isValid(grid, r, c, n)) {
            grid[r][c] = n;
            count += countSolutions(grid);
            grid[r][c] = 0;
            if (count >= 2) return count;
        }
    }
    return count;
}

function generateSudoku(clues) {
    // å®Œå…¨ãªè§£ã‚’ç”Ÿæˆ
    let fullGrid = createEmptyGrid();
    fillGrid(fullGrid);
    solutionGrid = JSON.parse(JSON.stringify(fullGrid));

    // ã‚»ãƒ«ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å‰Šé™¤ã—ã¦ãƒ‘ã‚ºãƒ«ã‚’ä½œæˆ
    let puzzle = JSON.parse(JSON.stringify(fullGrid));
    let cells = [];
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            cells.push([r, c]);
        }
    }
    shuffle(cells);

    let toRemove = CELL_COUNT - clues;
    for (const [r, c] of cells) {
        if (toRemove <= 0) break;
        
        const backup = puzzle[r][c];
        puzzle[r][c] = 0;
        
        // ä¸€æ„æ€§ã‚’ãƒã‚§ãƒƒã‚¯
        const check = JSON.parse(JSON.stringify(puzzle));
        if (countSolutions(check) !== 1) {
            puzzle[r][c] = backup;
        } else {
            toRemove--;
        }
    }
    return puzzle;
}

// ============================================================
// ã‚¿ã‚¤ãƒãƒ¼æ©Ÿèƒ½
// ============================================================

function startTimer() {
    clearInterval(timerInterval);
    seconds = 0;
    timerInterval = setInterval(() => {
        seconds++;
        const min = String(Math.floor(seconds / 60)).padStart(2, '0');
        const sec = String(seconds % 60).padStart(2, '0');
        timeElement.textContent = `${min}:${sec}`;
    }, 1000);
}

function stopTimer() {
    clearInterval(timerInterval);
}

function resetStats() {
    stopTimer();
    seconds = 0;
    timeElement.textContent = "00:00";
}

// ============================================================
// UI æç”»ã¨æ“ä½œ
// ============================================================

function renderCell(cellElement) {
    const value = parseInt(cellElement.dataset.value || "0");
    const memos = (cellElement.dataset.memos || "").split(',').filter(m => m !== '').map(Number);
    
    cellElement.innerHTML = '';
    
    if (value !== 0) {
        // æ•°å­—ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆ
        cellElement.classList.remove('memo-mode');
        const span = document.createElement('span');
        span.className = 'main-number';
        span.textContent = value;
        cellElement.appendChild(span);
    } else if (memos.length > 0) {
        // ãƒ¡ãƒ¢ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆ
        cellElement.classList.add('memo-mode');
        const memoContainer = document.createElement('div');
        memoContainer.classList.add('memo-container');
        
        for (let i = 1; i <= SIZE; i++) {
            const span = document.createElement('span');
            if (memos.includes(i)) {
                span.textContent = i;
            }
            memoContainer.appendChild(span);
        }
        cellElement.appendChild(memoContainer);
    } else {
        // ç©ºã®ã‚»ãƒ«
        cellElement.classList.remove('memo-mode');
        cellElement.innerHTML = '';
    }
}

function initGrid() {
    gridElement.innerHTML = "";
    
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.r = r;
            cell.dataset.c = c;
            cell.dataset.value = "0";
            cell.dataset.memos = "";
            
            cell.addEventListener('click', () => selectCell(cell));
            gridElement.appendChild(cell);
        }
    }
}

function loadPuzzle(pzl) {
    initialPuzzle = JSON.parse(JSON.stringify(pzl));
    
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
            const value = pzl[r][c];

            cell.classList.remove('fixed', 'error');
            cell.dataset.value = value.toString();
            cell.dataset.memos = "";
            
            if (value !== 0) {
                cell.classList.add("fixed");
            } else {
                cell.classList.remove("fixed");
            }
            
            renderCell(cell);
        }
    }
    
    clearSelection();
    clearHighlighting();
    resetStats();
    startTimer();
    history = [];
    
    // åˆå›ãƒ­ãƒ¼ãƒ‰æ™‚ã€ãƒã‚§ãƒƒã‚¯ãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’è¨­å®š
    document.getElementById("check-toggle").classList.add('check-mode-active');
}

function selectCell(cell) {
    if (selectedCell === cell) {
        clearSelection();
        return;
    }
    
    clearSelection();
    selectedCell = cell;
    selectedCell.classList.add('selected');
    highlightRelatedCells(selectedCell.dataset.r, selectedCell.dataset.c);
}

function clearSelection() {
    if (selectedCell) {
        selectedCell.classList.remove('selected');
        selectedCell = null;
    }
    clearHighlighting();
}

function highlightRelatedCells(r, c) {
    clearHighlighting();
    const br = Math.floor(r / 3) * 3;
    const bc = Math.floor(c / 3) * 3;

    document.querySelectorAll('.cell').forEach(cell => {
        const cellR = parseInt(cell.dataset.r);
        const cellC = parseInt(cell.dataset.c);
        const cellBr = Math.floor(cellR / 3) * 3;
        const cellBc = Math.floor(cellC / 3) * 3;

        if (cellR == r || cellC == c || (cellBr == br && cellBc == bc)) {
            cell.classList.add('highlighted');
        }
    });
}

function clearHighlighting() {
    document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('highlighted');
    });
}

// â˜…ä¿®æ­£: ãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã®ON/OFFã§ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
function checkAndHighlightErrors() {
    const currentValues = getGridValuesFromCells();
    document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('error'));
    
    let hasError = false;

    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const val = currentValues[r][c];
            if (val !== 0) {
                const cellElement = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
                
                // 1. é‡è¤‡ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ (å¸¸ã«å®Ÿè¡Œ)
                const isValidMove = isValid(currentValues, r, c, val);
                
                // 2. è§£ç­”ä¸æ­£è§£ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ (ãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã®ã¿å®Ÿè¡Œ)
                if (!cellElement.classList.contains('fixed')) { 
                    if (!isValidMove) {
                        // é‡è¤‡ã‚¨ãƒ©ãƒ¼ã¯å¸¸ã«èµ¤ãã™ã‚‹
                        cellElement.classList.add('error');
                        hasError = true;
                    } else if (isCheckMode && val !== solutionGrid[r][c]) {
                        // ãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ONã‹ã¤ä¸æ­£è§£ã®å ´åˆã®ã¿èµ¤ãã™ã‚‹
                        cellElement.classList.add('error');
                        hasError = true;
                    }
                }
            }
        }
    }
    return hasError;
}

function checkWinCondition() {
    const currentValues = getGridValuesFromCells();
    const isFull = currentValues.flat().every(val => val !== 0);
    const hasError = checkAndHighlightErrors(); 

    if (isFull && !hasError) {
        stopTimer();
        const min = String(Math.floor(seconds / 60)).padStart(2, '0');
        const sec = String(seconds % 60).padStart(2, '0');
        setTimeout(() => {
            alert(`ğŸ‰ ãƒ‘ã‚ºãƒ«ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼\nâ±ï¸ ã‚¯ãƒªã‚¢æ™‚é–“: ${min}:${sec}`);
        }, 100);
        return true;
    }
    return false;
}

// ============================================================
// UI æç”»ã¨æ“ä½œ - è‡ªå‹•ãƒ¡ãƒ¢æ¶ˆå»
// ============================================================

/**
 * ç¢ºå®šå€¤ãŒå…¥åŠ›ã•ã‚ŒãŸã‚»ãƒ«ã«é–¢é€£ã™ã‚‹è¡Œãƒ»åˆ—ãƒ»ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰ã€ãã®ç¢ºå®šå€¤ã‚’ãƒ¡ãƒ¢ã‹ã‚‰æ¶ˆå»ã™ã‚‹
 * @param {number} r ç¢ºå®šå€¤ãŒå…¥åŠ›ã•ã‚ŒãŸè¡Œ
 * @param {number} c ç¢ºå®šå€¤ãŒå…¥åŠ›ã•ã‚ŒãŸåˆ—
 * @param {number} val ç¢ºå®šå€¤
 */
function clearRelatedMemos(r, c, val) {
    const br = Math.floor(r / 3) * 3;
    const bc = Math.floor(c / 3) * 3;
    let changedCells = [];
    
    for (let i = 0; i < SIZE; i++) {
        // åŒä¸€è¡Œãƒ»åŒä¸€åˆ—
        const rowCell = document.querySelector(`.cell[data-r="${r}"][data-c="${i}"]`);
        const colCell = document.querySelector(`.cell[data-r="${i}"][data-c="${c}"]`);
        
        // åŒä¸€ãƒ–ãƒ­ãƒƒã‚¯
        const blockR = br + Math.floor(i / 3);
        const blockC = bc + (i % 3);
        const blockCell = document.querySelector(`.cell[data-r="${blockR}"][data-c="${blockC}"]`);
        
        for (const cell of [rowCell, colCell, blockCell]) {
            if (!cell || cell.classList.contains('fixed')) continue;
            
            const cellR = parseInt(cell.dataset.r);
            const cellC = parseInt(cell.dataset.c);
            
            // ç¢ºå®šå€¤ãŒå…¥åŠ›ã•ã‚ŒãŸã‚»ãƒ«è‡ªä½“ã¯ã‚¹ã‚­ãƒƒãƒ—
            if (cellR === r && cellC === c) continue;
            
            // ã™ã§ã«ç¢ºå®šå€¤ãŒå…¥ã£ã¦ã„ã‚‹ã‚»ãƒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
            if (parseInt(cell.dataset.value) !== 0) continue; 
            
            let memos = (cell.dataset.memos || "").split(',').filter(m => m !== '').map(Number);
            const valIndex = memos.indexOf(val);
            
            if (valIndex > -1) {
                // ãƒ¡ãƒ¢ã‹ã‚‰å€¤ã‚’å‰Šé™¤
                memos.splice(valIndex, 1);
                cell.dataset.memos = memos.sort((a, b) => a - b).join(',');
                changedCells.push(cell);
            }
        }
    }
    
    // å¤‰æ›´ã•ã‚ŒãŸã‚»ãƒ«ã®UIã‚’æ›´æ–°
    changedCells.forEach(cell => renderCell(cell));
}

// ============================================================
// ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰æ“ä½œ
// ============================================================

function toggleMemoMode() {
    isMemoMode = !isMemoMode;
    memoToggleButton.classList.toggle('memo-mode-active', isMemoMode);
    memoToggleButton.innerHTML = isMemoMode ? "ãƒ¡ãƒ¢<br>(ON)" : "ãƒ¡ãƒ¢<br>(OFF)";
}

// â˜…æ–°è¦è¿½åŠ : ãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
function toggleCheckMode() {
    const checkToggleButton = document.getElementById("check-toggle");
    isCheckMode = !isCheckMode;

    checkToggleButton.classList.toggle('check-mode-active', isCheckMode);
    checkToggleButton.textContent = isCheckMode ? 'ğŸ” ãƒ’ãƒ³ãƒˆ (ON)' : 'âŒ ãƒ’ãƒ³ãƒˆ (OFF)';

    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’æ›´æ–°
    checkAndHighlightErrors(); 
}

function handleKeypadInput(num) {
    if (!selectedCell || selectedCell.classList.contains('fixed')) return;

    saveStateToHistory();

    const r = parseInt(selectedCell.dataset.r);
    const c = parseInt(selectedCell.dataset.c);
    const oldValue = parseInt(selectedCell.dataset.value || "0");
    const oldMemos = selectedCell.dataset.memos;
    
    if (isMemoMode) {
        // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰
        if (oldValue !== 0) return;

        let memos = (oldMemos || "").split(',').filter(m => m !== '').map(Number);
        const numIndex = memos.indexOf(num);
        
        if (num === 0) {
            // ãƒ¡ãƒ¢ã‚’å…¨å‰Šé™¤
            selectedCell.dataset.memos = "";
        } else if (numIndex > -1) {
            // æ—¢å­˜ã®ãƒ¡ãƒ¢ã‚’å‰Šé™¤
            memos.splice(numIndex, 1);
            selectedCell.dataset.memos = memos.sort((a, b) => a - b).join(',');
        } else {
            // æ–°ã—ã„ãƒ¡ãƒ¢ã‚’è¿½åŠ 
            memos.push(num);
            selectedCell.dataset.memos = memos.sort((a, b) => a - b).join(',');
        }
    } else {
        // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰
        selectedCell.dataset.memos = "";

        if (num === 0) {
            selectedCell.dataset.value = "0";
        } else {
            selectedCell.dataset.value = num.toString();
        }

        // â˜…ä¿®æ­£: ãƒã‚§ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ãŒONã®å ´åˆã€ã‹ã¤æ­£è§£ã®å ´åˆã®ã¿ãƒ¡ãƒ¢æ¶ˆå»ã‚’ãƒˆãƒªã‚¬ãƒ¼
        if (isCheckMode && num !== 0 && num === solutionGrid[r][c]) {
            clearRelatedMemos(r, c, num);
        }
    }
    
    renderCell(selectedCell);
    checkAndHighlightErrors(); 
    checkWinCondition();
}

// ============================================================
// Undoæ©Ÿèƒ½
// ============================================================

function saveStateToHistory() {
    // é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã‚„å›ºå®šã‚»ãƒ«ã¯å±¥æ­´ã«ä¿å­˜ã—ãªã„
    if (!selectedCell || selectedCell.classList.contains('fixed')) return;

    // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
    history.push({
        r: parseInt(selectedCell.dataset.r),
        c: parseInt(selectedCell.dataset.c),
        value: selectedCell.dataset.value,
        memos: selectedCell.dataset.memos,
    });
    
    if (history.length > MAX_HISTORY) {
        history.shift();
    }
}

function undo() {
    if (history.length === 0) {
        alert("ã“ã‚Œä»¥ä¸Šæˆ»ã‚‹æ“ä½œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
        return;
    }

    const prevState = history.pop();
    const cellToRestore = document.querySelector(`.cell[data-r="${prevState.r}"][data-c="${prevState.c}"]`);

    if (cellToRestore && !cellToRestore.classList.contains('fixed')) {
        cellToRestore.dataset.value = prevState.value;
        cellToRestore.dataset.memos = prevState.memos;

        renderCell(cellToRestore);
        selectCell(cellToRestore);
        checkAndHighlightErrors();
        
    } else {
        // æ„å›³ã›ãšå›ºå®šã‚»ãƒ«ã‚’Undoã—ã‚ˆã†ã¨ã—ãŸå ´åˆã€æ¬¡ã®å±¥æ­´ã‚’ãƒã‚§ãƒƒã‚¯
        if (history.length > 0) undo();
    }
}

// ============================================================
// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³æ“ä½œ
// ============================================================

function generatePuzzle() {
    const clues = parseInt(document.getElementById("clues").value);
    let pzl = generateSudoku(clues);
    loadPuzzle(pzl);
}

async function confirmGiveUp() {
    const confirmed = await showConfirmDialog(
        "ã‚®ãƒ–ã‚¢ãƒƒãƒ—ç¢ºèª",
        "ç­”ãˆã‚’è¦‹ã¾ã™ã‹ï¼Ÿ\nè§£ç­”ã‚’è¡¨ç¤ºã™ã‚‹ã¨ã€ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¾ã™ã€‚"
    );
    
    if (confirmed) {
        solvePuzzle();
    }
}

function solvePuzzle() {
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
            if (!cell.classList.contains('fixed')) {
                cell.dataset.value = solutionGrid[r][c].toString();
                cell.dataset.memos = "";
            }
        }
    }
    
    document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('error'));
    document.querySelectorAll('.cell').forEach(renderCell);
    stopTimer();
    
    setTimeout(() => {
        alert("ğŸ³ï¸ ã‚®ãƒ–ã‚¢ãƒƒãƒ—ï¼è§£ç­”ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚");
    }, 100);
    
    history = [];
    clearSelection();
}

async function resetPuzzle() {
    if (!initialPuzzle || initialPuzzle.length === 0) {
        alert("æœ€åˆã«ãƒ‘ã‚ºãƒ«ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚");
        return;
    }
    
    const confirmed = await showConfirmDialog(
        "ãƒªã‚»ãƒƒãƒˆç¢ºèª",
        "ãƒ‘ã‚ºãƒ«ã‚’æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ã®é€²è¡ŒçŠ¶æ³ã¯å¤±ã‚ã‚Œã¾ã™ã€‚"
    );
    
    if (!confirmed) return;
    
    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
            if (!cell.classList.contains('fixed')) {
                cell.dataset.value = "0";
                cell.dataset.memos = "";
            }
        }
    }
    
    document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('error'));
    document.querySelectorAll('.cell').forEach(renderCell);
    
    resetStats();
    startTimer();
    
    history = [];
    clearSelection();
}

// ============================================================
// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œã®ã‚µãƒãƒ¼ãƒˆ
// ============================================================

document.addEventListener('keydown', (e) => {
    if (!selectedCell) return;
    
    const key = e.key;
    
    // æ•°å­—ã‚­ãƒ¼ (1-9)
    if (key >= '1' && key <= '9') {
        e.preventDefault();
        handleKeypadInput(parseInt(key));
    }
    // Deleteã‚­ãƒ¼ã€Backspaceã‚­ãƒ¼ã€0ã‚­ãƒ¼
    else if (key === 'Delete' || key === 'Backspace' || key === '0') {
        e.preventDefault();
        handleKeypadInput(0);
    }
    // çŸ¢å°ã‚­ãƒ¼ã§ã‚»ãƒ«ç§»å‹•
    else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        e.preventDefault();
        const r = parseInt(selectedCell.dataset.r);
        const c = parseInt(selectedCell.dataset.c);
        
        let newR = r;
        let newC = c;
        
        if (key === 'ArrowUp' && r > 0) newR = r - 1;
        if (key === 'ArrowDown' && r < SIZE - 1) newR = r + 1;
        if (key === 'ArrowLeft' && c > 0) newC = c - 1;
        if (key === 'ArrowRight' && c < SIZE - 1) newC = c + 1;
        
        const newCell = document.querySelector(`.cell[data-r="${newR}"][data-c="${newC}"]`);
        if (newCell) selectCell(newCell);
    }
    // Mã‚­ãƒ¼ã§ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    else if (key === 'm' || key === 'M') {
        e.preventDefault();
        toggleMemoMode();
    }
    // Zã‚­ãƒ¼ã§å…ƒã«æˆ»ã™ (Ctrl+Z ã¾ãŸã¯ Cmd+Z)
    else if ((e.ctrlKey || e.metaKey) && key === 'z') {
        e.preventDefault();
        undo();
    }
});

// ============================================================
// åˆæœŸè¨­å®š
// ============================================================
initGrid();
generatePuzzle();
</script>

</body>
</html>